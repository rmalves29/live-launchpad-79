-- Criar tabela para etiquetas
CREATE TABLE public.customer_tags (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  color TEXT DEFAULT '#3B82F6',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Criar tabela de relacionamento cliente-etiqueta
CREATE TABLE public.customer_tag_assignments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  customer_id BIGINT NOT NULL REFERENCES public.customers(id) ON DELETE CASCADE,
  tag_id BIGINT NOT NULL REFERENCES public.customer_tags(id) ON DELETE CASCADE,
  assigned_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  UNIQUE(customer_id, tag_id)
);

-- Habilitar RLS
ALTER TABLE public.customer_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.customer_tag_assignments ENABLE ROW LEVEL SECURITY;

-- Políticas RLS para etiquetas
CREATE POLICY "Public can manage customer tags" 
ON public.customer_tags 
FOR ALL 
USING (true) 
WITH CHECK (true);

-- Políticas RLS para atribuições de etiquetas
CREATE POLICY "Public can manage customer tag assignments" 
ON public.customer_tag_assignments 
FOR ALL 
USING (true) 
WITH CHECK (true);

-- Inserir a etiqueta "APP" se não existir
INSERT INTO public.customer_tags (name, color) 
VALUES ('APP', '#10B981') 
ON CONFLICT (name) DO NOTHING;

-- Criar índices para performance
CREATE INDEX idx_customer_tag_assignments_customer_id ON public.customer_tag_assignments(customer_id);
CREATE INDEX idx_customer_tag_assignments_tag_id ON public.customer_tag_assignments(tag_id);

-- Trigger para atualizar updated_at
CREATE TRIGGER update_customer_tags_updated_at
  BEFORE UPDATE ON public.customer_tags
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- Função para adicionar etiqueta APP quando mensagem em massa for enviada
CREATE OR REPLACE FUNCTION public.add_app_tag_on_bulk_message()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  v_app_tag_id BIGINT;
  v_customer_id BIGINT;
BEGIN
  -- Só processar se for uma mensagem do tipo bulk/mass
  IF NEW.type = 'bulk' OR NEW.type = 'mass' OR NEW.type = 'broadcast' THEN
    
    -- Buscar ID da etiqueta APP
    SELECT id INTO v_app_tag_id 
    FROM customer_tags 
    WHERE name = 'APP';
    
    -- Se a etiqueta APP não existir, criar
    IF v_app_tag_id IS NULL THEN
      INSERT INTO customer_tags (name, color) 
      VALUES ('APP', '#10B981') 
      RETURNING id INTO v_app_tag_id;
    END IF;
    
    -- Buscar ID do cliente pelo telefone
    SELECT id INTO v_customer_id 
    FROM customers 
    WHERE phone = NEW.phone;
    
    -- Se encontrou o cliente, adicionar a etiqueta APP
    IF v_customer_id IS NOT NULL AND v_app_tag_id IS NOT NULL THEN
      INSERT INTO customer_tag_assignments (customer_id, tag_id) 
      VALUES (v_customer_id, v_app_tag_id)
      ON CONFLICT (customer_id, tag_id) DO NOTHING;
    END IF;
    
  END IF;
  
  RETURN NEW;
END;
$$;

-- Criar trigger que executa após inserir mensagem
CREATE TRIGGER trigger_add_app_tag_on_bulk_message
  AFTER INSERT ON public.whatsapp_messages
  FOR EACH ROW
  EXECUTE FUNCTION public.add_app_tag_on_bulk_message();